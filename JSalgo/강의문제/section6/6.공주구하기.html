<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      `정보 왕국의 이웃 나라 외동딸 공주가 숲속의 괴물에게 잡혀갔습니다.
      정보 왕국에는 왕자가 N명이 있는데 서로 공주를 구하러 가겠다고 합니다. 정보왕국의 왕은 다음과 같은 방법으로 공주를 구하러 갈 왕자를 결정하기로 했습니다.
      왕은 왕자들을 나이 순으로 1번부터 N번까지 차례로 번호를 매긴다. 그리고 1번 왕자부터 N 번 왕자까지 순서대로 시계 방향으로 돌아가며 동그랗게 앉게 한다. 그리고 1번 왕자부터 시 계방향으로 돌아가며 1부터 시작하여 번호를 외치게 한다. 한 왕자가 K(특정숫자)를 외치면 그 왕자는 공주를 구하러 가는데서 제외되고 원 밖으로 나오게 된다. 그리고 다음 왕자부터 다시 1부터 시작하여 번호를 외친다.
      이렇게 해서 마지막까지 남은 왕자가 공주를 구하러 갈 수 있다.`;

      function solution(n, k) {
        // let answer;
        // let arr = [];

        // for (let i = 1; i <= 8; i++) {
        //   arr.push(i);
        // }

        // for (let j = 0; j <= 8; j++) {
        //   arr = [...arr.slice(k), ...arr.slice(0, k - 1)];
        //   console.log(arr);
        // }

        // return answer;

        let answer;
        let queue = Array.from({ length: n }, (v, i) => i + 1);

        while (queue.length) {
          for (let i = 1; i < k; i++) queue.push(queue.shift());
          queue.shift();
          if (queue.length === 1) answer = queue.shift();
        }
        return answer;
      }

      document.write(solution(8, 3), "<br>");
    </script>
  </body>
</html>

<!-- Array.from() 메서드는 유사 배열 객체(array-like object)나 반복 가능한 객체(iterable object)를 얕게 복사해 새로운Array 객체를 만듭니다. -->

<!-- console.log(Array.from('foo'));
// expected output: Array ["f", "o", "o"]

console.log(Array.from([1, 2, 3], x => x + x));
// expected output: Array [2, 4, 6] -->
