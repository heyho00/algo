# BIG O

어떤 문제에 해결법은 무수히 많지만 문제에 접근하는 방식은 다를 수 있다.

어느것이 더 좋은지 알 수 있을까?

그것이 **빅오의 핵심**이다.

숫자로 코드의 성능을 표기할 수 있다는 것이다.

<br>

좋은 코드를 쓴다는 것은 많은 메모리 양을 사용하지 않는 효율적인 코드를 쓰면서

읽기 쉽게 쓰는 것. 이 두가지를 잘 조율 하는 것.

```js
function addUpTo(n) {
    let total = 0
    for(let i =1; i<=n;i++) {
        total+=i;
    }
    return total
}

---------------------------

function addUpTo2(n) {
    return n * (n+1) /2
}
```

우선 실행하는데 걸리는 시간으로 평가할 수 있다.

```js
let t1 = performance.now() //이 창이 열린 시간
addUpTo(1000000000)
let t2 = performance.now()  // addUpTo을 호출하고 걸린 시간
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds`)
```

이런식으로 테스트하면 addUpTo2가 더 빠르다.

이렇게 수동적으로 타이밍을 구하고 비교하는것이 가장 좋은 방법은 아니다.

기기 사양에 따라 다를수도 있고 완전히 믿을 수 없다.

시간을 측정않고 어느 코드가 더 좋은지 평가하는법?

<br>

**대신에 컴퓨터가 처리해야하는 연산 갯수를 세면 된다.**

addUpTo2를 보면 * + / 연산을 3번 한다.

n이 크든 작든 상관없이.

첫번째는 for 안에 +가 있어서 n의 숫자에 따라 연산의 갯수가 늘어난다.

그리고 (let i=1; i<=n; i++) 여기도 연산이다.

2번 코드보다 확실히 연산의 갯수가 많다.

1번 코드에서의 연산갯수는 `5n + 2`로 표현할 수 있다.

n이 커질수록 연산의 갯수도 늘어난다는 것이 중요하다.

<br>

## BIG O에 대한 공식 소개

어떤 펑션의 입력 값이 늘어나는 것과 펑션 실행 시간이 변하는 관계를 의미.

입력의 크기와 실행 시간의 관계.

```js
function addUpTo(n) {
    return n * (n+1) /2
}

// 언제나 연산 3개 -> O(1)

function addUpTo(n) {
    let total = 0
    for(let i =1; i<=n;i++) {
        total+=i;
    }
    return total
}

// 2n이든 5이든 상관없이 O(n)
// n이 커질수록 연산이 늘어나는 것.

```

<br>

전체적인 추세가 중요하다.

5n +2를 n으로 단순화했다.

O(2n) 은 O(n)

O(500)은 O(1)

연산 갯수가 어떤 상황에든 500개 있다는 것이니,.단순화 가능.

